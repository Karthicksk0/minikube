name: CI/CD to Minikube

on:
  push:
    branches: [ main ]

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest
    env:
      MINIKUBE_VERSION: "1.35.0"
      KUBECTL_VERSION: "v1.27.0"

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Run a basic test
        run: |
          python -c "from app import app; print('app import OK')"

      - name: Install prerequisites (conntrack)
        run: |
          sudo apt-get update
          sudo apt-get install -y conntrack

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Install minikube
        run: |
          curl -Lo minikube https://storage.googleapis.com/minikube/releases/${MINIKUBE_VERSION}/minikube-linux-amd64
          chmod +x minikube
          sudo mv minikube /usr/local/bin/

      - name: Start minikube (docker driver)
        run: |
          # start minikube (may take ~30s)
          sudo minikube start --driver=docker --memory=4096 --wait=true
          minikube update-context
        shell: bash

      - name: Build image inside Minikube's Docker daemon
        run: |
          # Point docker to minikube daemon then build image so cluster can use it without pushing to a registry
          eval $(minikube -p minikube docker-env)
          docker build -t flask-app:1.0 .
        shell: bash

      - name: Configure kubectl to use Minikube kubeconfig (sanity check)
        run: |
          export KUBECONFIG="$(minikube kubeconfig)"
          echo "Using KUBECONFIG: $KUBECONFIG"
          kubectl cluster-info
        shell: bash

      - name: Apply manifests (kube/ or repo root)
        run: |
          export KUBECONFIG="$(minikube kubeconfig)"
          # prefer manifests in ./kube if present, else try root files
          if [ -d kube ]; then
            kubectl apply -f kube/
          else
            kubectl apply -f deployment.yaml || true
            kubectl apply -f service.yaml || true
            [ -f ingress.yaml ] && kubectl apply -f ingress.yaml || true
          fi
        shell: bash

      - name: Wait for rollout
        run: |
          export KUBECONFIG="$(minikube kubeconfig)"
          kubectl rollout status deployment/flask-app --timeout=180s
          kubectl get pods -o wide
        shell: bash

